- What is XSS?
    Cross-site Scripting. It is a type of injection. Malicious script is injected into web sites.

- Where can it occur (be injected)?
    Anywhere a web application uses input from user within the output it generates without validating or encoding it.

- What are the 2 conditions for XSS to take place?
    Data enters a web application throught an untrusted source
    The data is included in dynamic content that is sent to a web user without being validated for malicious content

- What kind of attacks can be done with XSS?
    Transmiting pricate data (cookies, session info), redirecting the victim to some place controlled by the attacker, or performing malicious operations on the web site.

- What are the 3 types of XSS?
    Stored XSS
    Reflected XSS
    DOM based XSS (2005)

- What are the alternative types of XSS (compared to those above)? Define them.
    Both can be stored or reflected.
    Server XSS
        Untrusted user suplied data that is now included in a HTML response generated by the server, the source of the data can be from a request or from a stored location. The vulnerability is on the server side code, the browser simply execute what it is given.
        
        - What are the recommended defenses for server XSS?
            Context-sensitive server side output encoding is the easiest and stringest defense. Input validation or data sanitization can be done, but it is more difficult to get correct.
    Client XSS
        Untrusted user data is used to update the DOM with an unsafe JS call (a call that introduce valid JS in the DOM). The data can come from the DOM or as been sent by the server. 

        - What are the recommended defenses for client XSS?
            Using safe JS APIs. But it is sometime hard to know if the API or feature of the API is safe. Other times, you know the method is not safe, and cannot find an alternative, then you have to fall back on context sensitive ouput encoding in the browser.

- Describe each of them.
    Stored XSS
        The injected script is stored on the target servers, like in a DB, a forum, a comment section, etc. The victim then retrieves the script when it requests the stored information.
    Reflected XSS
        The injected script is reflected off the web server, like an error message, a search result, etc. (things that contain parts or all of the user input in the response).
        - How is it delivered to the victim?
            Via another route, like an email or from another web site. When the user is tricked to click on the malicious link, send a malicious form, or browsing a malicious site, the injected code travels the vulnerable website and the attack is reflected to the user browser. Then, browser execute the script.
    DOM based XSS
        ###
        --- TODO ---
        ###

- Does the consequence of an XSS change depending of the type used?
    No. The only difference is in how the payload arrives at the server.

- What kind of consequenses? Given some examples.
    Range from annoyance to account compromise. Disclosure of session cookie (session hijacking), disclosure of end user files, installation of Trojan horse programs, redirect the user, modify presentation content. Example: modify a press release, modify medication dosage.

- How to determine if you are vulnerable?
    Perform a security review of the code and search for all places where input from an HTTP request could possibly make its way into the HTML output.

- Give alternatives for XSS syntax. (XSS attacks that do not use <script></script> tag) (There are a lot, just give a few)
    Use script in attributes
        <body onload=alert(1)>
        <b onmouseover=alert(1)>Some text to over</b>
        <img src="[...]" onerror=alert(document.cookie)>

    Encoded URI schemes
        If the web application has some filters, we can try to encode string characters (ex: a=&#X41 in UTF-8)
        <img src=j&#X41vascript:alert(1)>

    Code encoding
        Encode the script in Base64 and place it in META tag (<meta> provides metadata about the HTML document, will not be displayed on the page, but will be machine parsable.)
        <META HTTP-EQUIV="refresh"
        CONTENT="0;url=data:text/html;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg">

- How do you protect/prevent your web site against XSS?
    In a nutshell: perform the appropriate validation and escaping on the server-side

    0 - Disable HTTP TRACE support: an attacker can steal cookie data via JS even if document.cookie is disabled or not supported.

    1- Whitelist input values if possible (dropdown, numbers only, etc.)

    2- HTML escape before inserting untrusted data into HTML element content.
         String safe = ESAPI.encoder().encodeForHTML( request.getParameter( "input" ) );

    3- Attribute escape before inserting untrusted data into common attributes
        Common attributes ar ewidth, name, value, etc. Not: href, src, style, event handlers.
        Except for alphanumeric characters, escape all characters with ASCII values less than 256 to prevent switching out of the attribute (ex : <[...] name=input> ---> <[...] name=""> [some malicious injection] <!--)

        String safe = ESAPI.encoder().encodeForHTMLAttribute( request.getParameter( "input" ) );

    4- JS escape before inserting untrusted data into JS data values
        The only safe place to put untrusted escaped data into JS code is inside a quoted data value. But, there are still JS functions that are never safe, like window.setInterval('ESCAPED DATA IS NOT SAFE');

        Except for alphanumeric characters, escape all characters less than 256 to prevent switching out of the data value into the script context or into another attribute.

        String safe = ESAPI.encoder().encodeForJavaScript( request.getParameter( "input" ) );

    5- HTML escape JSON values in an HTML context and read the data with JSON.parse
        Ensure returned Content-Type header is application/json and not text/html. This instructs the browser to not misunderstand the context and execute injected script

    6- CSS escape and strictly validate before inserting untrusted data into HTML style property values
        For when you want to put untrusted data into a stylesheet or a style tag. There are css contexts that are never safe, for example all URLs (background-url: "javascript:alert(1)";). Have to ensure that URLs starts with http, not javascript.

        String safe = ESAPI.encoder().encodeForCSS( request.getParameter( "input" ) );

    7- URL escape before inserting untrusted data into URL parameter values
        Except for alphanumeric characters, escape all characters with ASCII values less than 256.

    8- If the use of HTML markup is expected from the user, use a specialized library to handle the sanitization of the user input.

    The use of the HTTPONLY flag on the cookies helps to protect against cookie theft

    Implement Content Security Policy (CSP)
        Mitigate XSS by instructing the browser to only execute or render resources from those sources
        Ex: Content-Security-Policy: default-src: 'self'; script-src: 'self' static.domain.tld
            Tells the browser to load all resources only from the page's origin and JS source code files.

    Use the X-XSS-Protection Response Header
        - Is it enabled by default?
            Yes. But it may have been disabled by the user, so better set it to be sure.
        

    - Can you just Entity encode all untrusted data and be done with it?
        No. entity encoding does not work if you put untrusted data inside a <script> tag, or in an event handler, or in a URL. You MUST use escape syntax for the part of the HTML document you are putting untrusted data into.

- Do web application frameworks provide automatic contextual escaping functionality?
    Some yes, like AngularJS strict contextual escaping

- How do you protect/prevent your web site against DOM based XSS?
    ###
    --- TODO ---
    ###